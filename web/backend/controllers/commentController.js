/**
 * FILE: web/backend/controllers/commentController.js
 * M·ª§C ƒê√çCH: X·ª≠ l√Ω c√°c thao t√°c li√™n quan ƒë·∫øn comments
 * LI√äN QUAN:
 *   - web/backend/models/Comment.js
 *   - web/backend/models/Post.js
 *   - web/backend/models/User.js
 *   - web/backend/routes/commentRoutes.js
 * CH·ª®C NƒÇNG:
 *   - T·∫°o comment
 *   - Reply comment
 *   - L·∫•y danh s√°ch comments
 *   - C·∫≠p nh·∫≠t comment
 *   - X√≥a comment
 *   - C√≥ th·ªÉ attach ·∫£nh v√†o comment
 */

const Comment = require("../models/Comment");
const Post = require("../models/Post");
const User = require("../models/User");
const Notification = require("../models/Notification");
const Vote = require("../models/Vote");

// @desc    T·∫°o comment m·ªõi
// @route   POST /api/comments
// @access  Private
exports.createComment = async (req, res, next) => {
  try {
    const { postId, content, parentComment, mediaUrl } = req.body;

    // Ki·ªÉm tra user c√≥ quy·ªÅn comment kh√¥ng
    const user = await User.findById(req.user.id);
    const canComment = user.canCreateComment();

    if (!canComment.allowed) {
      return res.status(403).json({
        success: false,
        message: canComment.reason,
      });
    }

    // Ki·ªÉm tra post t·ªìn t·∫°i
    const post = await Post.findById(postId);
    if (!post || post.isDeleted) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt",
      });
    }

    // N·∫øu l√† reply, ki·ªÉm tra parent comment (FB-like: gom v·ªÅ root, c√≥ replyTo)
    let depth = 0;
    let rootParentId = null;
    let replyToUser = null;
    if (parentComment) {
      const parent = await Comment.findById(parentComment);
      if (!parent || parent.isDeleted) {
        return res.status(404).json({
          success: false,
          message: "Kh√¥ng t√¨m th·∫•y comment g·ªëc",
        });
      }
      if (parent.depth >= 1 && parent.parentComment) {
        rootParentId = parent.parentComment;
        replyToUser = parent.author;
      } else {
        rootParentId = parent._id;
        replyToUser = parent.author;
      }
      depth = 1; // UI ch·ªâ hi·ªÉn th·ªã 2 c·∫•p
    }

    // AI Analysis t·ª´ middleware
    const aiAnalysis = req.aiAnalysis || {};

    // Log AI Analysis
    console.log(
      "ü§ñ AI Analysis (Comment):",
      JSON.stringify(aiAnalysis, null, 2)
    );

    // Check if toxic - reject ho·∫∑c warning
    const TOXIC_THRESHOLD = 0.7; // N·∫øu score > 70% th√¨ reject

    if (aiAnalysis.isToxic && aiAnalysis.toxicScore > TOXIC_THRESHOLD) {
      return res.status(400).json({
        success: false,
        message: `N·ªôi dung c·ªßa b·∫°n c√≥ th·ªÉ ch·ª©a ng√¥n t·ª´ kh√¥ng ph√π h·ª£p (toxic score: ${(
          aiAnalysis.toxicScore * 100
        ).toFixed(1)}%). Vui l√≤ng ƒëi·ªÅu ch·ªânh l·∫°i n·ªôi dung.`,
      });
    }

    // Update emotion field
    const emotion = aiAnalysis.emotion || "neutral";

    // T·∫°o comment
    const comment = await Comment.create({
      post: postId,
      author: req.user.id,
      content,
      parentComment: rootParentId || parentComment || null,
      replyTo: replyToUser || null,
      depth,
      mediaUrl: mediaUrl || null,
      emotion: {
        label: emotion,
        confidence: aiAnalysis.emotionScore || 0,
        analyzedAt: aiAnalysis.analyzedAt || null,
      },
      aiAnalysis: {
        isToxic: aiAnalysis.isToxic || false,
        toxicScore: aiAnalysis.toxicScore || 0,
        toxicType: aiAnalysis.toxicType || "clean",
        analyzedAt: aiAnalysis.analyzedAt || null,
      },
    });

    // Update post stats
    post.stats.commentsCount += 1;
    await post.save();

    // Update user stats
    user.stats.commentsCount += 1;

    // Ki·ªÉm tra v√† unlock post permission n·∫øu ƒë·ªß 3 comments
    if (user.stats.commentsCount >= 3) {
      user.restrictions.canPost = true;
    }

    user.updateBadge();
    await user.save();

    // N·∫øu l√† reply, tƒÉng repliesCount c·ªßa root parent
    if (rootParentId) {
      await Comment.findByIdAndUpdate(rootParentId, {
        $inc: { "stats.repliesCount": 1 },
      });
    }

    // T·∫°o notification: Ai ƒë√≥ b√¨nh lu·∫≠n v√†o post c·ªßa b·∫°n (post_comment)
    try {
      if (post.author && post.author.toString() !== req.user.id) {
        await Notification.createNotification({
          recipient: post.author,
          sender: req.user.id,
          type: "post_comment",
          title: "B√¨nh lu·∫≠n m·ªõi",
          message: `${user.username} ƒë√£ b√¨nh lu·∫≠n v√†o b√†i vi·∫øt c·ªßa b·∫°n`,
          targetType: "Post",
          targetId: post._id,
          link: `/post/${post.slug}#comments`,
          metadata: { commentId: comment._id },
        });
      }

      // N·∫øu l√† reply v√†o b√¨nh lu·∫≠n c·ªßa ng∆∞·ªùi kh√°c -> th√¥ng b√°o cho ƒë√∫ng ng∆∞·ªùi ƒë∆∞·ª£c tr·∫£ l·ªùi
      if (replyToUser && replyToUser.toString() !== req.user.id) {
        await Notification.createNotification({
          recipient: replyToUser,
          sender: req.user.id,
          type: "comment_reply",
          title: "Tr·∫£ l·ªùi m·ªõi",
          message: `${user.username} ƒë√£ tr·∫£ l·ªùi b√¨nh lu·∫≠n c·ªßa b·∫°n`,
          targetType: "Comment",
          targetId: rootParentId || parentComment,
          link: `/post/${post.slug}#comments`,
          metadata: { commentId: comment._id },
        });
      }
    } catch (e) {
      // Kh√¥ng ch·∫∑n request n·∫øu l·ªói th√¥ng b√°o
      console.error("Notification error (post_comment):", e.message);
    }

    // Populate v√† return
    await comment.populate("author", "username avatar badge");

    res.status(201).json({
      success: true,
      message: "T·∫°o comment th√†nh c√¥ng",
      data: comment,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    L·∫•y comments c·ªßa b√†i vi·∫øt
// @route   GET /api/comments/post/:postId
// @access  Public
exports.getCommentsByPost = async (req, res, next) => {
  try {
    const { postId } = req.params;
    const {
      page = 1,
      limit = 50,
      sort = "best",
      parentComment = null,
    } = req.query;

    const skip = (parseInt(page) - 1) * parseInt(limit);

    // Build query
    const query = {
      post: postId,
      isDeleted: false,
      parentComment: parentComment || null,
    };

    // Build sort
    let sortQuery = {};
    switch (sort) {
      case "new":
        sortQuery = { createdAt: -1 };
        break;
      case "old":
        sortQuery = { createdAt: 1 };
        break;
      case "top":
        sortQuery = { "stats.upvotes": -1 };
        break;
      case "best":
      default:
        sortQuery = { score: -1, createdAt: -1 };
        break;
    }

    const comments = await Comment.find(query)
      .sort(sortQuery)
      .skip(skip)
      .limit(parseInt(limit))
      .populate("author", "username avatar badge")
      .lean();

    const total = await Comment.countDocuments(query);

    // L·∫•y s·ªë l∆∞·ª£ng replies: ch·ªâ t√≠nh cho comment c·∫•p 0
    for (let comment of comments) {
      if (comment.depth === 0) {
        comment.repliesCount = await Comment.countDocuments({
          parentComment: comment._id,
          isDeleted: false,
        });
      } else {
        comment.repliesCount = 0;
      }

      // N·∫øu user ƒëang ƒëƒÉng nh·∫≠p, l·∫•y vote status
      if (req.user) {
        const vote = await Vote.findOne({
          user: req.user.id,
          targetType: "Comment",
          targetId: comment._id,
        });
        comment.userVote = vote ? vote.voteType : null;
      }
    }

    res.status(200).json({
      success: true,
      data: {
        comments,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

// @desc    L·∫•y replies c·ªßa comment
// @route   GET /api/comments/:commentId/replies
// @access  Public
exports.getCommentReplies = async (req, res, next) => {
  try {
    const { commentId } = req.params;
    const { page = 1, limit = 20, sort = "best" } = req.query;

    const skip = (parseInt(page) - 1) * parseInt(limit);

    // Replies lu√¥n theo m·ªëc th·ªùi gian (c≈© tr∆∞·ªõc m·ªõi) ƒë·ªÉ gi·ªØ m·∫°ch h·ªôi tho·∫°i
    const sortQuery = { createdAt: 1 };

    const replies = await Comment.find({
      parentComment: commentId,
      isDeleted: false,
    })
      .sort(sortQuery)
      .skip(skip)
      .limit(parseInt(limit))
      .populate("author", "username avatar badge")
      .populate("replyTo", "username")
      .lean();

    const total = await Comment.countDocuments({
      parentComment: commentId,
      isDeleted: false,
    });

    // N·∫øu user ƒëang ƒëƒÉng nh·∫≠p, l·∫•y vote status
    if (req.user) {
      for (let reply of replies) {
        const vote = await Vote.findOne({
          user: req.user.id,
          targetType: "Comment",
          targetId: reply._id,
        });
        reply.userVote = vote ? vote.voteType : null;
      }
    }

    res.status(200).json({
      success: true,
      data: {
        replies,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

// @desc    C·∫≠p nh·∫≠t comment
// @route   PUT /api/comments/:commentId
// @access  Private
exports.updateComment = async (req, res, next) => {
  try {
    const { commentId } = req.params;
    const { content, mediaUrl } = req.body;

    const comment = await Comment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y comment",
      });
    }

    // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
    if (comment.author.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: "B·∫°n kh√¥ng c√≥ quy·ªÅn ch·ªânh s·ª≠a comment n√†y",
      });
    }

    // Update
    if (content) comment.content = content;
    if (mediaUrl !== undefined) comment.mediaUrl = mediaUrl;

    comment.isEdited = true;
    comment.editedAt = Date.now();

    await comment.save();

    await comment.populate("author", "username avatar badge");

    res.status(200).json({
      success: true,
      message: "C·∫≠p nh·∫≠t comment th√†nh c√¥ng",
      data: comment,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    X√≥a comment
// @route   DELETE /api/comments/:commentId
// @access  Private
exports.deleteComment = async (req, res, next) => {
  try {
    const { commentId } = req.params;

    const comment = await Comment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y comment",
      });
    }

    // Ki·ªÉm tra quy·ªÅn (owner ho·∫∑c admin/moderator)
    const user = await User.findById(req.user.id);
    if (
      comment.author.toString() !== req.user.id &&
      user.role !== "admin" &&
      user.role !== "moderator"
    ) {
      return res.status(403).json({
        success: false,
        message: "B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a comment n√†y",
      });
    }

    // Soft delete
    comment.isDeleted = true;
    comment.content = "[Comment ƒë√£ b·ªã x√≥a]";
    await comment.save();

    // Update post stats
    await Post.findByIdAndUpdate(comment.post, {
      $inc: { "stats.commentsCount": -1 },
    });

    // Update user stats
    await User.findByIdAndUpdate(comment.author, {
      $inc: { "stats.commentsCount": -1 },
    });

    res.status(200).json({
      success: true,
      message: "X√≥a comment th√†nh c√¥ng",
    });
  } catch (error) {
    next(error);
  }
};

// @desc    L·∫•y chi ti·∫øt comment
// @route   GET /api/comments/:commentId
// @access  Public
exports.getComment = async (req, res, next) => {
  try {
    const { commentId } = req.params;

    const comment = await Comment.findById(commentId)
      .populate("author", "username avatar badge stats")
      .populate("post", "title slug")
      .lean();

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y comment",
      });
    }

    // L·∫•y parent comment n·∫øu c√≥
    if (comment.parentComment) {
      const parent = await Comment.findById(comment.parentComment)
        .populate("author", "username avatar badge")
        .lean();

      comment.parentCommentData = parent;
    }

    // N·∫øu user ƒëang ƒëƒÉng nh·∫≠p, l·∫•y vote status
    if (req.user) {
      const vote = await Vote.findOne({
        user: req.user.id,
        targetType: "Comment",
        targetId: comment._id,
      });
      comment.userVote = vote ? vote.voteType : null;
    }

    res.status(200).json({
      success: true,
      data: comment,
    });
  } catch (error) {
    next(error);
  }
};
